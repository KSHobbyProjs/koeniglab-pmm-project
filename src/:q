#!/usr/bin/env python
import physics_models as pm
import numpy as np
import ec
import matplotlib.pyplot as plt
import pickle
import pmm

if __name__=="__main__":
    # load Gaussian model
    N = 128
    gauss = pm.gaussian_1d.Gaussian1d(N)

    # import ground state energies and eigenvectors
    with open("../data/gauss1d_energies.pkl", "rb") as f:
        data = pickle.load(f)

    gs_actual = data["Ls"]
    Es_actual = data["energies"]
    
    # get sampling data
    k_num = 2
    gs_sample = 5 + np.linspace(0, 1, 20)**1.5 * (20 - 5)
    Es_sample = gauss.get_eigenvalues(gs_sample, k_num=k_num)

    # normalize Es_sample (TEST)
    Es_sample_mean0 = np.mean(Es_sample[:,0])
    Es_sample_std0 = np.std(Es_sample[:,0])
    Es_sample_mean1 = np.mean(Es_sample[:,1])
    Es_sample_std1 = np.mean(Es_sample[:,1])
    Es_train0 = (Es_sample[:,0] - Es_sample_mean0) / Es_sample_std0
    Es_train1 = (Es_sample[:,1] - Es_sample_mean1) / Es_sample_std1
    Es_train = np.stack((Es_train0, Es_train1), axis=1)
      
    # define pmm
    epochs = 25000
    store_loss = 100
    dim = 10
    pmm_gauss = pmm.PMM(dim=dim,num_primary=2, eta=1e-2, l2=0.0, mag=1e-1, seed=153)
    # input sampling data
    pmm_gauss.sample(gs=gs_sample, Es=Es_train)
    # train pmm and grab loss
    params, loss = pmm_gauss.train(epochs=epochs, store_loss=store_loss)
    pmm_gauss.store(path="../data/gauss_state.pkl")
    # predict using trained pmm
    Es_predict = pmm_gauss.predict(gs_actual, k_num=k_num)
    Es_predict0 = Es_predict[:,0] * Es_sample_std0 + Es_sample_mean0
    Es_predict1 = Es_predict[:,1] * Es_sample_std1 + Es_sample_mean1
    Es_predict = np.stack((Es_predict0, Es_predict1), axis=1)
    #Es_predict = Es_predict * Es_sample_std + Es_sample_mean # re-normalize

    # plot and print loss 
    print(loss[-1])
    fig, ax = plt.subplots()
    ax.plot(store_loss * np.arange(len(loss)), np.log10(loss), '-')
    ax.set_xlabel("Epochs")
    ax.set_ylabel("log(loss)")
    ax.set_title("Loss vs Epochs")
    plt.show()
   
    # plot actual data, sample points, and predictions
    for k in range(k_num):
        fig, ax = plt.subplots()
        ax.plot(gs_actual, Es_actual[:,k], '-', label="Actual")
        ax.plot(gs_sample, Es_sample[:,k], 'o', label="Sample")
        ax.plot(gs_actual, Es_predict[:,k], '--', label="Predictions")
        ax.set_xlabel("System Length")
        ax.set_ylabel("Energy")
        ax.set_title(f"Energy vs System Size: k:{k}")
        ax.legend()
    plt.show()

    """
    # plot ground state eigenvector
    L_index = 10
    L = Ls_actual[L_index]
    a_phys = L / N
    psi = states[L_index]
    psi2 = np.abs(psi)**2 / a_phys**3
    
    ys2d, xs2d = np.indices((N, N))
    xs2d = (xs2d.flatten() - N / 2) * a_phys
    ys2d = (ys2d.flatten() - N / 2) * a_phys
    plt.scatter(xs2d, ys2d, c=psi2[:N**2]*a_phys, cmap='viridis')
    plt.colorbar()
    plt.show()

    # dilate ground state eigenvector and plot
    L_target = 10
    a_phys = L_target / N
    psi_dilated = ec.EC.dilate(L, L_target, psi)
    psi_dilated2 = np.abs(psi_dilated)**2 / a_phys**3

    ys2d, xs2d = np.indices((N, N))
    xs2d = (xs2d.flatten() - N / 2) * a_phys
    ys2d = (ys2d.flatten() - N / 2) * a_phys 
    plt.scatter(xs2d, ys2d, c=psi_dilated2[:N**2]*a_phys, cmap='viridis')
    plt.colorbar()
    plt.show()
    """
    
    """
    # use EC to find predictions for ground state energies
    Ls_train = np.arange(5, 13) 
    Es_train = gauss.get_eigenvalues(Ls_train)
    Es_predict, _ = gauss_ec.solve(Ls_train, Ls_actual, k_num_sample=6, k_num_predict=1, dilate=False)
    
    # find index
    L_star = 20
    temp = np.ones_like(Ls_actual) * L_star
    error = abs(Ls_actual - temp)
    i = np.argmin(error)
    print(Ls_actual[i])
    print(Es_predict[i])

    fig, ax = plt.subplots()
    ax.plot(Ls_train, Es_train, 'o', label='training values')
    ax.plot(Ls_actual, Es_actual, '-', label='test energies')
    ax.plot(Ls_actual, Es_predict, '--', label='prediction')
    ax.set_xlabel('System Size L')
    ax.set_ylabel('Ground State Energy E')
    ax.set_title('Ground State Energy vs System Size')
    ax.legend()
    plt.show() 
    """

